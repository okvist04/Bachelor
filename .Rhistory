arma24.garch11 <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(2,4), include.mean = TRUE),
distribution.model = "norm")
arma24.garch11.fit <- ugarchfit(spec = arma24.garch11, data = return2014, out.sample = 100,
solver = "hybrid")
plot(arma24.garch11.fit, which = "all")
arma24.garch11.fit
checkresiduals(ar.mod)
arma24.garch11.fit
# Observing if the above conclusion is correct
stand.res.14 <- residuals(arma24.garch11.fit, standardize = TRUE)
acf(stand.res.14, main = "Standardized Residuals")
sqr.stand.res.14 <- stand.res.14^2
acf(sqr.stand.res.14, main = "Squared Standardized Residuals")
# Calculating the accuracy of the model
MSE(arma24.garch11.fit@fit$fitted.values, return2014)
accuracy(arma24.garch11.fit@fit$fitted.values, return2014[355:365])
# Forecasting; static and rolling, conditional mean and sigma
forecast_arma24garch11 <- ugarchforecast(arma24.garch11.fit, data = return2014,
n.ahead = 10, n.roll = 100)
print(forecast_arma24garch11)
plot(forecast_arma24garch11, which = "all")
######################################################################################
# ARMA-GARCH model for 2015, static and rolling forecast
# Based on BIC, the best model is ARMA(3,3)-GARCH(1,1), BIC = -4.068104
######################################################################################
return2015 <- return[457:821]
arma.mod2015 <- auto.arima(return2015, approximation = FALSE, stepwise = FALSE, allowmean = FALSE,
allowdrift = FALSE); coeftest(arma.mod2015) # AR(5)
# Checking it the found AR model is causal and invertible
autoplot(arma.mod2015) # Causal and invertible
ar.mod2015 <- ar.mle(return2015, aic = TRUE, order.max = NULL, intercept = TRUE) # AR(8)
# Checking it the found AR model is causal and invertible
autoplot(ar.mod2015) # Causal and invertible
# Calculating the accuracy of both models, first from auto.arima then from ar.mle
MSE(fitted(arma.mod2015), return2015)
accuracy(fitted(arma.mod2015), return2015)
MSE(fitted(ar.mod2015)[9:365], return2015[9:365])
accuracy(fitted(ar.mod2015)[9:365], return2015[9:365])
checkresiduals(arma.mod2015, test = "LB")
t.2015 <- seq(as.Date("2015-01-01"), by = "month", along.with = c(return2015, return[822:1187]))
par(mfrow = c(1,1))
# Forecasting based on ARMA(5,0,0), auto.arima
arma.forecast2015 <- forecast::forecast(arma.mod2015, h = 10, level = c(80,95))
plot(arma.forecast2015, xaxt = "n", main = "10 Days ahead Forecast, AR(5)")
lines(return[822:831], type = "l",
col = "green", lty = 2); axis.Date(1, at = t.2015, format= "%m/%Y", las = 2)
legend("bottom", legend = c("Actual, 2015", "Forecast", "Actual, 2016"),
col = c("black", "steelblue", "green"), lty = c(1,1,2), cex = 0.55, box.lty = 0)
# Forecasting based on AR(8), ar.mle
ar.forecast2015 <- forecast::forecast(ar.mod2015, h = 10, level = c(80,95))
plot(ar.forecast2015, xaxt = "n", main = "10 Days ahead Forecast, AR(8)")
lines(return[822:831], type = "l",
col = "green", lty = 2); axis.Date(1, at = t.2015, format= "%m/%Y", las = 2)
legend("bottomleft", legend = c("Actual, 2015", "Forecast", "Actual, 2016"),
col = c("black", "steelblue", "green"), lty = c(1,1,2), cex = 0.55, box.lty = 0)
# Checking for signs of conditional heteoryskedasticity, i.e., GARCH effects
par(mfrow = c(1,1))
McLeod.Li.test(arma.mod2015, main = "McLeod-Li test statistics for 2014 Returns")
arma33.garch11 <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(3,3), include.mean = TRUE),
distribution.model = "norm")
arma33.garch11.fit <- ugarchfit(spec = arma33.garch11, data = return2015, out.sample = 100,
solver = "hybrid")
plot(arma33.garch11.fit, which = "all")
arma33.garch11.fit
# Observing if the above conclusion is correct
stand.res.15 <- residuals(arma33.garch11.fit, standardize = TRUE)
acf(stand.res.15, main = "Standardized Residuals")
sqr.stand.res.15 <- stand.res.15^2
acf(sqr.stand.res.15, main = "Squared Standardized Residuals")
# Calculating the accuracy of the model
MSE(arma33.garch11.fit@fit$fitted.values, return2015)
accuracy(arma33.garch11.fit@fit$fitted.values, return2015[355:365])
# Forecasting; static and rolling, conditional mean and sigma
forecast_arma33garch11 <- ugarchforecast(arma33.garch11.fit,
data = return2015, n.ahead = 10, n.roll = 100)
print(forecast_arma33garch11)
plot(forecast_arma33garch11, which = "all")
######################################################################################
# Based on AMIM value, the models are made based on the inefficient months.
# Three months are chosen, highest: October 16, lowest: May 18, median: September 18
######################################################################################
#Monthly Windows:
oct2016 <- window(return, start = as.Date("2016-10-01"), end = as.Date("2016-10-31")) # Highest
nov2016 <- window(return, start = as.Date("2016-11-01"), end = as.Date("2016-11-30"))
may2018 <- window(return, start = as.Date("2018-05-01"), end = as.Date("2018-05-31")) # Lowest
jun2018 <- window(return, start = as.Date("2018-06-01"), end = as.Date("2018-06-30"))
sep2018 <- window(return, start = as.Date("2018-09-01"), end = as.Date("2018-09-30")) # Median
oct2018 <- window(return, start = as.Date("2018-10-01"), end = as.Date("2018-10-31"))
######################################################################################
# Month with highest AMIM - Oct. 2016 = 0.5026904, modelling
######################################################################################
arma.oct2016 <- auto.arima(oct2016, trace = TRUE, stepwise = FALSE, approximation = FALSE,
allowmean = FALSE, allowdrift = FALSE) # ARMA(0,0,0)
# Checking it the found ARMA model is causal and invertible
autoplot(arma.oct2016) # Causal and invertible
ar.oct2016 <- ar.mle(oct2016, aic = TRUE, order.max = NULL, intercept = TRUE) # AR(11)
# Checking it the found AR model is causal and invertible
autoplot(ar.oct2016) # Causal and invertible
# Calculating the accuracy of both models, first from auto.arima then from ar.mle
MSE(fitted(arma.oct2016), oct2016)
accuracy(fitted(arma.oct2016), oct2016)
MSE(fitted(ar.oct2016)[12:31], oct2016[12:31])
accuracy(fitted(ar.oct2016)[12:31], oct2016[12:31])
checkresiduals(arma.oct2016, std = TRUE, start = 1)
checkresiduals(arma.oct2016, type = "LB")
# White noise
checkresiduals(ar.oct2016, type = "LB")
######################################################################################
# Month with smallest AMIM, May 2018, AMIM = 0.0019, modelling
######################################################################################
arma.may2018 <- auto.arima(may2018, trace = TRUE, stepwise = FALSE, approximation = FALSE,
allowmean = FALSE, allowdrift = FALSE, ic = "aic"); coeftest(arma.may2018)
# Checking it the found AR model is causal and invertible
autoplot(arma.may2018) # Causal and invertible
ar.may2018 <- ar.mle(may2018, aic = TRUE, order.max = NULL, intercept = TRUE)
# Checking it the found AR model is causal and invertible
autoplot(ar.may2018) # Causal and invertible
# Calculating the accuracy of both models, first from auto.arima then from ar.mle
MSE(fitted(arma.may2018), may2018)
accuracy(fitted(arma.may2018), may2018)
MSE(fitted(ar.may2018)[4:31], may2018[4:31])
accuracy(fitted(ar.may2018)[4:31], may2018[4:31])
checkresiduals(arma.may2018, type = "LB")
checkresiduals(ar.may2018, type = "LB")
######################################################################################
# Month with AMIM in the middle of Sep 2018 AMIM = 0.266, modelling
######################################################################################
arma.sep2018 <- auto.arima(sep2018, trace = TRUE, stepwise = FALSE, approximation = FALSE,
allowmean = FALSE, allowdrift = FALSE, ic = "aic"); coeftest(arma.sep2018)
# Checking it the found AR model is causal and invertible
autoplot(arma.sep2018) # Causal and invertible
ar.sep2018 <- ar.mle(sep2018, aic = TRUE, order.max = NULL, intercept = TRUE)
# Checking it the found AR model is causal and invertible
autoplot(ar.sep2018) # Causal and invertible
# Calculating the accuracy of both models, first from auto.arima then from ar.mle
MSE(fitted(arma.sep2018), sep2018)
accuracy(fitted(arma.sep2018), sep2018)
MSE(fitted(ar.sep2018)[5:30], sep2018[5:30])
accuracy(fitted(ar.sep2018)[5:30], sep2018[5:30])
checkresiduals(arma.sep2018, type = "LB")
checkresiduals(ar.sep2018)
checkresiduals(arma.sep2018)
# Checking if residuals are white noise.
checkresiduals(arma.may2018)
checkresiduals(ar.may2018)
# Checking if the residuals are white noise
checkresiduals(arma.oct2016)
checkresiduals(ar.oct2016)
LjungBoxTest(residuals(arma.may2018))
Box.test(arma.may2018, type = "Ljung-Box")
?Box.test
Box.test(residuals(arma.may2018), type = "Ljung-Box")
checkresiduals(arma.may2018)
# Checking if the residuals are indeed white noise
checkresiduals(arma.mod)
checkresiduals(arma.mod, test = "LB")
checkresiduals(ar.mod)
checkresiduals(ar.mod2014)
checkresiduals(ar.oct2016)
Box.test(ar.mod2014, type = "Ljung-Box")
Box.test(residuals(ar.mod2014), type = "Ljung-Box")
?Box.test
checkresiduals(ar.mod2015); Box.test(residuals(ar.mod2015), type = "Ljung-Box")
# Checking if the residuals are white noise
checkresiduals(arma.oct2016)
checkresiduals(ar.oct2016)
checkresiduals(ar.oct2016); Box.test(residuals(ar.oct2016), type = "Ljung-Box")
checkresiduals(ar.may2018); Box.test(residuals(ar.may2018), type = "Ljung-Box")
checkresiduals(ar.sep2018); Box.test(residuals(ar.sep2018), type = "Ljung-Box")
checkresiduals(arma32.garch42.fit)
checkresiduals(arma32.garch42.fit@fit$residuals)
Box.test(arma32.garch42.fit@fit$residuals, type = "Ljung-Box")
arma32.garch42.fit
arma24.garch11.fit
arma33.garch11.fit
#install.packages("itsmr")
library(corrgram)
library(astsa); library(TSA)
library(tseries); library(xts)
library(forecast); library(fGarch)
library(ggplot2); library(timeSeries)
library(itsmr); library(rugarch)
library(zoo); library(MLmetrics)
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "red") #Looks non-stationary
plot(return)
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "red")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "rainbow")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "aquamarine3")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "RdBu")
install.packages("RColorBrewer")
library(zoo); library(xts); library(RColorBrewer)
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "RdBu")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = brewer.pal(n = 10, name = "RdBu"))
display.brewer.pal(n = 8, name = 'RdBu')
plot(return, ylab = "Returns (USD)", xlab = "Years", col = brewer.pal(n = 8, name = "RdBu"))
plot(return, ylab = "Returns (USD)", xlab = "Years", col = brewer.pal(n = 2756, name = "RdBu"))
plot(return, ylab = "Returns (USD)", xlab = "Years", col = brewer.pal(n = 11, name = "RdBu"))
plot(return, ylab = "Returns (USD)", xlab = "Years", col = rainbow(2600))
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "chocolate4")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "cadetblue4")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "aquamarine")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "aquamarine2")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "#33CCCC")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "cadetblue1")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "cadetblue2")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "#33CCCC")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "#33CCCC",
main = "Returns 02/10/2013 - 18/04/2021")
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices") #Looks non-stationary
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "#33CCCC",
main = "Returns 02/10/2013 - 18/04/2021")
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices") #Looks non-stationary
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "#33CCCC") #Looks non-stationary
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "#33CCCC", grid = TRUE) #Looks non-stationary
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "#33CCCC", lwd = 4) #Looks non-stationary
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "#33CCCC", lwd = 3) #Looks non-stationary
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "#33CCCC", lwd = 2) #Looks non-stationary
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "red", lwd = 2) #Looks non-stationary
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "red", lwd = 1.5) #Looks non-stationary
plot(closing_price, ylab = "Price (USD)", xlab = "Years", main = "Closing Prices",
col = "red", lwd = 1) #Looks non-stationary
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "#33CCCC",
main = "Returns 02/10/2013 - 18/04/2021")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "black",
main = "Returns 02/10/2013 - 18/04/2021")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "#33CCCC",
main = "Returns 02/10/2013 - 18/04/2021")
plot(return, ylab = "Returns (USD)", xlab = "Years", col = "#FFCC00",
main = "Returns 02/10/2013 - 18/04/2021")
# The time series appear to be stationary
acf(return)
library(arfima); library(astsa); library(fGarch); library(FitAR); library(forecast)
library(fUnitRoots); library(ie2misc); library(itsmr); library(lmtest); library(MLmetrics)
library(rmgarch); library(timeDate); library(timeSeries); library(TSA); library(tseries)
library(zoo); library(xts); library(RColorBrewer)
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
return <- diff(closing_price) / closing_price[1:2757]
plot(return, ylab = "", xlab = "", col = "#FFCC00",
main = "Returns 02/10/2013 - 18/04/2021")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaix = TRUE,
main = "Returns 02/10/2013 - 18/04/2021")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021"); axis.Date(1, at = td, format = "%Y")
axis.Date(1, at = td, format = "%Y")
axis.Date(9, at = td, format = "%Y")
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "years")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
td.years
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "years")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
td.years
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "months")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "days")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "years")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "months")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
?axis.Date
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td, format = "%Y")
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "Years")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td, format = "%Y")
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "years")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td, format = "%Y")
axis.Date(1, at = td.years, format = "%Y")
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "years")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
library(arfima); library(astsa); library(fGarch); library(FitAR); library(forecast)
library(fUnitRoots); library(ie2misc); library(itsmr); library(lmtest); library(MLmetrics)
library(rmgarch); library(timeDate); library(timeSeries); library(TSA); library(tseries)
library(zoo); library(xts); library(RColorBrewer)
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
return <- diff(closing_price) / closing_price[1:2757]
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "years")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
arma.mod <- auto.arima(return, approximation = FALSE, stepwise = FALSE, allowmean = FALSE,
allowdrift = FALSE); coeftest(arma.mod) # ARMA(4,1)
# ARMA(3,2)-GARCH(4,2) lowest BIC = -3.77051
arma32.garch42 <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(4,2)),
mean.model = list(armaOrder = c(3,2), include.mean = TRUE),
distribution.model = "norm")
arma32.garch42.fit <- ugarchfit(spec = arma32.garch42, data = return,
out.sample = 100, solver = "hybrid")
par(mfrow = c(4,3))
plot(arma32.garch42.fit, which = "all")
arma32.garch42.fit
######################################################################################
# Based on AMIM value, the models are made based on the inefficient years, i.e., 2014 & 2015
######################################################################################
t2 <- window(return, start = as.Date("2014-01-01"), end = as.Date("2014-12-31")) #Inefficient
t3 <- window(return, start = as.Date("2015-01-01"), end = as.Date("2015-12-31")) #Inefficient
######################################################################################
# ARMA-GARCH model for 2014, static and rolling forecast
# Based on BIC, the best model is ARMA(2,4)-GARCH(1,1), BIC = -3.797563
######################################################################################
return2014 <- return[92:456]
arma.mod2014 <- auto.arima(return2014, approximation = FALSE, stepwise = FALSE, allowmean = FALSE,
allowdrift = FALSE); coeftest(arma.mod2014) # AR(2)
arma24.garch11.fit <- ugarchfit(spec = arma24.garch11, data = return2014, out.sample = 100,
solver = "hybrid")
arma24.garch11.fit
######################################################################################
# ARMA-GARCH model for 2015, static and rolling forecast
# Based on BIC, the best model is ARMA(3,3)-GARCH(1,1), BIC = -4.068104
######################################################################################
return2015 <- return[457:821]
arma.mod2015 <- auto.arima(return2015, approximation = FALSE, stepwise = FALSE, allowmean = FALSE,
allowdrift = FALSE); coeftest(arma.mod2015) # AR(5)
arma33.garch11.fit <- ugarchfit(spec = arma33.garch11, data = return2015, out.sample = 100,
solver = "hybrid")
arma33.garch11.fit
library(arfima); library(astsa); library(fGarch); library(FitAR); library(forecast)
library(fUnitRoots); library(ie2misc); library(itsmr); library(lmtest); library(MLmetrics)
library(rmgarch); library(timeDate); library(timeSeries); library(TSA); library(tseries)
library(zoo); library(xts); library(RColorBrewer)
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
return <- diff(closing_price) / closing_price[1:2757]
td.years <- seq(as.Date("2013-10-01"), as.Date("2021-10-01"), "years")
plot(return, ylab = "", xlab = "", col = "#FFCC00", xaxt = "n",
main = "Returns 02/10/2013 - 18/04/2021")
axis.Date(1, at = td.years, format = "%Y")
arma.mod <- auto.arima(return, approximation = FALSE, stepwise = FALSE, allowmean = FALSE,
allowdrift = FALSE); coeftest(arma.mod) # ARMA(4,1)
# Checking it the found ARMA model is causal and invertible
autoplot(arma.mod) # Causal and invertible
ar.mod <- ar.mle(return, aic = TRUE, order.max = NULL, intercept = TRUE) # AR(10)
# Checking it the found AR model is causal and invertible
autoplot(ar.mod) # Causal
# Calculating the accuracy of the models, first for the auto.arima the for ar.mle
MSE(fitted(arma.mod), return)
accuracy(fitted(arma.mod), return)
# Calculating the fitted values, and finding the accuracy
fitted.ar.mod <- ts(return[11:2756] - ar.mod$resid[11:2756])
MSE(fitted.ar.mod, return[11:2756])
accuracy(fitted.ar.mod, return[11:2756])
# Checking if the residuals are indeed white noise
checkresiduals(arma.mod)
# Forecasting using ARMA(4,1)
tendaysahead <- read.table("BTC_USD_2021-04-20_2021-04-29-CoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
tenaheaddates <- as.Date(tendaysahead$Date)
td.tenahead <- seq(as.Date("2021-04-20"), as.Date("2021-04-29"), "days")
closing_price.tenahead <- zoo(x = tendaysahead$Closing.Price..USD., order.by = td.tenahead)
tendaysahead.return <- diff(closing_price.tenahead) / closing_price.tenahead[1:9]
t.all <- seq(as.Date("2013-01-01"), as.Date("2021-04-29"), by = "month")
arma.forecast <- forecast::forecast(arma.mod, h = 10, level = c(80, 95))
par(mfrow = c(1,1))
plot(arma.forecast, xaxt = "n", main = "10 Days ahead Forecast, ARMA(4,1)", xlim = c(18300, 18733))
lines(tendaysahead.return, type = "l", col = "green",
lty = 2); axis.Date(1, at = t.all, format= "%m/%Y", las = 2)
tendaysahead.return
return
lines(tendaysahead.return, type = "l", col = "green",
lty = 2); axis.Date(1, at = t.all, format= "%m/%Y", las = 2)
legend("bottomleft", legend = c("Actual Returns 20/02 - 18/04/21",
"Forecast", "Actual Returns 20/04/21 - 28/04/21"),
col = c("black", "steelblue", "green"), lty = c(1,1,2), cex = 0.55, box.lty = 0)
plot(arma.forecast, xaxt = "n", main = "10 Days ahead Forecast, ARMA(4,1)", xlim = c(18300, 18733))
lines(tendaysahead.return, type = "l", col = "green",
lty = 2); axis.Date(1, at = t.all, format= "%m/%Y", las = 2)
legend("topleft", legend = c("Actual Returns 20/02 - 18/04/21",
"Forecast", "Actual Returns 20/04/21 - 28/04/21"),
col = c("black", "steelblue", "green"), lty = c(1,1,2), cex = 0.55, box.lty = 0)
par(mfrow = c(1,1))
McLeod.Li.test(arma.mod, main = "McLeod-Li test statistics for Returns")
abs.return <- abs(return); acf2(abs.return) # Shows signs of ARCH effect
sqr.return <- return^2; acf2(sqr.return) # Shows signs of ARCH effect
acf(abs.return, main = "Absolute Value of Returns") # Shows signs of ARCH effect
# ARMA(3,2)-GARCH(4,2) lowest BIC = -3.77051
arma32.garch42 <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(4,2)),
mean.model = list(armaOrder = c(3,2), include.mean = TRUE),
distribution.model = "norm")
arma32.garch42.fit <- ugarchfit(spec = arma32.garch42, data = return,
out.sample = 100, solver = "hybrid")
par(mfrow = c(4,3))
plot(arma32.garch42.fit, which = "all")
arma32.garch42.fit
par(mfrow = c(1,1))
# Observing if the above conclusion is correct
stand.res <- residuals(arma32.garch42.fit, standardize = TRUE)
acf(stand.res, main = "Standardised Residuals")
sqr.stand.res <- stand.res^2
acf(sqr.stand.res, main = "Squared Standardised Residuals")
tendaysahead.return
?auto.arima
library(arfima)
library(astsa)
library(corrgram)
library(fastmap)
library(fBasics)
detach("package:fastmap", unload = TRUE)
library(fGarch)
library(FitAR)
library(forecast)
library(fracdiff)
library(fUnitRoots)
library(ie2misc)
library(itsmr)
library(lmtest)
library(MLmetrics)
library(parallel)
library(quantmod)
library(rmgarch)
library(TSA)
library(tseries)
library(arfima); library(astsa); library(fGarch); library(FitAR); library(forecast)
library(fUnitRoots); library(ie2misc); library(itsmr); library(lmtest); library(MLmetrics)
library(rmgarch); library(timeDate); library(timeSeries); library(TSA); library(tseries)
library(zoo); library(xts); library(RColorBrewer)
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
return <- diff(closing_price) / closing_price[1:2757]
constant.all <- auto.arima(y = return, d = NA, D = NA, max.p = 0, max.q = 0, max.order = 0)
constant.all
MSE(constant.all$fitted, return)
accuracy(constant.all$fitted, return)
######################################################################################
# Based on AMIM value, the models are made based on the inefficient years, i.e., 2014 & 2015
######################################################################################
t2 <- window(return, start = as.Date("2014-01-01"), end = as.Date("2014-12-31")) #Inefficient
t3 <- window(return, start = as.Date("2015-01-01"), end = as.Date("2015-12-31")) #Inefficient
######################################################################################
# ARMA-GARCH model for 2014, static and rolling forecast
# Based on BIC, the best model is ARMA(2,4)-GARCH(1,1), BIC = -3.797563
######################################################################################
return2014 <- return[92:456]
######################################################################################
# ARMA-GARCH model for 2015, static and rolling forecast
# Based on BIC, the best model is ARMA(3,3)-GARCH(1,1), BIC = -4.068104
######################################################################################
return2015 <- return[457:821]
######################################################################################
# Based on AMIM value, the models are made based on the inefficient months.
# Three months are chosen, highest: October 16, lowest: May 18, median: September 18
######################################################################################
#Monthly Windows:
oct2016 <- window(return, start = as.Date("2016-10-01"), end = as.Date("2016-10-31")) # Highest
nov2016 <- window(return, start = as.Date("2016-11-01"), end = as.Date("2016-11-30"))
may2018 <- window(return, start = as.Date("2018-05-01"), end = as.Date("2018-05-31")) # Lowest
jun2018 <- window(return, start = as.Date("2018-06-01"), end = as.Date("2018-06-30"))
sep2018 <- window(return, start = as.Date("2018-09-01"), end = as.Date("2018-09-30")) # Median
oct2018 <- window(return, start = as.Date("2018-10-01"), end = as.Date("2018-10-31"))
constant.2014 <- auto.arima(y = return2014, d = NA, D = NA, max.p = 0, max.q = 0, max.order = 0)
MSE(constant.2014$fitted, return2014)
constant.2014
accuracy(constant.2014$fitted, return2014)
constant.2015 <- auto.arima(y = return2015, d = NA, D = NA, max.p = 0, max.q = 0, max.order = 0)
constant.2015
MSE(constant.2015$fitted, return2015)
accuracy(constant.2015$fitted, return2015)
constant.oct16 <- auto.arima(y = oct2016, d = NA, D = NA, max.p = 0, max.q = 0, max.order = 0)
MSE(constant.oct16$fitted, oct2016)
accuracy(constant.oct16$fitted, oct2016)
constant.may18 <- auto.arima(y = may2018, d = NA, D = NA, max.p = 0, max.q = 0, max.order = 0)
MSE(constant.may18$fitted, may2018)
accuracy(constant.may18$fitted, may2018)
constant.sep18 <- auto.arima(y = sep2018, d = NA, D = NA, max.p = 0, max.q = 0, max.order = 0)
MSE(constant.sep18$fitted, sep2018)
accuracy(constant.sep18$fitted, sep2018)
