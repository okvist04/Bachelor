y= c(-0.8, 1.15, 1.82, 2.89, 1.43, 0.59, 1.09, 3, 2.81, 3.02, 2.39, 3.5, 3.06, 2.41, 2.81, 3.95, 4.19, 5.94, 7.06, 4.55)
x = 1:20
logL3 = function(p){ 1/2*sum((y-p[1]*p[2]^x - p[3])^2)}
x0 = c(2, 0.7, 0.2)
res3 = optim(x0, logL3, hessian = TRUE)
res3
var3 = solve(res3$hessian)
# Testing if gamma=0, it says TRUE if we accept it
abs((res3$par[3]-0)/sqrt(var3[3,3])) <= qnorm(1-0.05/2)
logL2 = function(p){ 1/2*sum((y-p[1]*p[2]^x)^2)}
x0 = c(2, 0.7)
res2 = optim(x0, logL2, hessian = TRUE)
res2
var2 = solve(res2$hessian)
# Testing if beta=1, it says True if we accept itdraw.ellipse(res1$par[1], res1$par[2], sqrt(5.991*eig1$values[1])
abs((res2$par[2]-1)/sqrt(var2[2,2])) <= qnorm(1-0.05/2)
# MLE'en i model 2 er
res2$par
var1 = solve(res2$hessian)[1,1]
var2 = solve(res2$hessian)[2,2]
#confidence interval er
conf_alpha = c(res2$par[1]-1.96*sqrt(var1), res2$par[1]+1.96*sqrt(var1)); conf_alpha
conf_beta = c(res2$par[2]-1.96*sqrt(var2), res2$par[2]+1.96*sqrt(var2)); conf_beta
#Observed information matrix is
solve(res2$hessian)
#Confidence region
eig = eigen(solve(res2$hessian))
theta = atan(eig$vectors[2,1]/eig$vectors[1,1])
plot(c(2,1), c(2,1), type="n",
xlim = c(0.3, 1.6)
,ylim = c(1.04, 1.15)
, main="Confidence region", xlab = expression(alpha), ylab=expression(beta))
draw.ellipse(res2$par[1], res2$par[2], 2*sqrt(5.991*eig$values[1])
,2*sqrt(5.991*eig$values[2]), angle=theta, deg=FALSE, lwd=2)
# Adding a plot comparing the data with fitted mean
plot(y~x)
z <- res2$par[1]*res2$par[2]^x
library("plotrix")
y= c(-0.8, 1.15, 1.82, 2.89, 1.43, 0.59, 1.09, 3, 2.81, 3.02, 2.39, 3.5, 3.06, 2.41, 2.81, 3.95, 4.19, 5.94, 7.06, 4.55)
x = 1:20
logL3 = function(p){ 1/2*sum((y-p[1]*p[2]^x - p[3])^2)}
x0 = c(2, 0.7, 0.2)
res3 = optim(x0, logL3, hessian = TRUE)
res3
var3 = solve(res3$hessian)
# Testing if gamma=0, it says TRUE if we accept it
abs((res3$par[3]-0)/sqrt(var3[3,3])) <= qnorm(1-0.05/2)
logL2 = function(p){ 1/2*sum((y-p[1]*p[2]^x)^2)}
x0 = c(2, 0.7)
res2 = optim(x0, logL2, hessian = TRUE)
res2
var2 = solve(res2$hessian)
# Testing if beta=1, it says True if we accept itdraw.ellipse(res1$par[1], res1$par[2], sqrt(5.991*eig1$values[1])
abs((res2$par[2]-1)/sqrt(var2[2,2])) <= qnorm(1-0.05/2)
# MLE'en i model 2 er
res2$par
var1 = solve(res2$hessian)[1,1]
var2 = solve(res2$hessian)[2,2]
#confidence interval er
conf_alpha = c(res2$par[1]-1.96*sqrt(var1), res2$par[1]+1.96*sqrt(var1)); conf_alpha
conf_beta = c(res2$par[2]-1.96*sqrt(var2), res2$par[2]+1.96*sqrt(var2)); conf_beta
#Observed information matrix is
solve(res2$hessian)
#Confidence region
eig = eigen(solve(res2$hessian))
theta = atan(eig$vectors[2,1]/eig$vectors[1,1])
plot(c(2,1), c(2,1), type="n",
xlim = c(0.3, 1.6)
,ylim = c(1.04, 1.15)
, main="Confidence region", xlab = expression(alpha), ylab=expression(beta))
draw.ellipse(res2$par[1], res2$par[2], 2*sqrt(5.991*eig$values[1])
,2*sqrt(5.991*eig$values[2]), angle=theta, deg=FALSE, lwd=2)
library("ellipse")
#Observed information matrix is
var <- solve(res2$hessian)
ellipse(var, centre = c(res2$par[1],res2$par[2]), level = 0.95, t = qchisq(0.95, 2))
plot(ellipse(var, centre = c(res2$par[1],res2$par[2]), level = 0.95, t = qchisq(0.95, 2)))
plot(ellipse(var, centre = c(res2$par[1],res2$par[2]), level = 0.95, t = qchisq(0.95, 2)), type = "l")
plot(c(2,1), c(2,1), type="n",
xlim = c(0.3, 2)
,ylim = c(1.04, 2)
, main="Confidence region", xlab = expression(alpha), ylab=expression(beta))
draw.ellipse(res2$par[1], res2$par[2], 2*sqrt(5.991*eig$values[1])
,2*sqrt(5.991*eig$values[2]), angle=theta, deg=FALSE, lwd=2)
plot(c(2,1), c(2,1), type="n",
xlim = c(-5, 10)
,ylim = c(-5, 10)
, main="Confidence region", xlab = expression(alpha), ylab=expression(beta))
draw.ellipse(res2$par[1], res2$par[2], 2*sqrt(5.991*eig$values[1])
,2*sqrt(5.991*eig$values[2]), angle=theta, deg=FALSE, lwd=2)
plot(c(2,1), c(2,1), type="n",
xlim = c(-1, 6)
,ylim = c(-1, 6)
, main="Confidence region", xlab = expression(alpha), ylab=expression(beta))
draw.ellipse(res2$par[1], res2$par[2], 2*sqrt(5.991*eig$values[1])
,2*sqrt(5.991*eig$values[2]), angle=theta, deg=FALSE, lwd=2)
plot(ellipse(var, centre = c(res2$par[1],res2$par[2]), level = 0.95, t = qchisq(0.95, 2)), type = "l")
R.version.string
install.packages(c("bitops", "boot", "brio", "broom", "callr", "caTools", "class", "cli", "cluster", "colorspace", "corrgram", "cpp11", "curl", "dbplyr", "desc", "devtools", "diffobj", "dplyr", "DT", "ellipsis", "farver", "gert", "gh", "glmnet", "haven", "highr", "httpuv", "isoband", "jquerylib", "KernSmooth", "knitr", "later", "lattice", "lubridate", "maptools", "MASS", "Matrix", "MatrixModels", "maxLik", "mgcv", "nnet", "openssl", "parallelly", "pbkrtest", "pcaPP", "pillar", "pkgload", "plm", "processx", "ps", "quantreg", "rbibutils", "RcppArmadillo", "remotes", "reprex", "rgl", "rio", "rlang", "rmarkdown", "rvest", "spatial", "survival", "tibble", "tidyr", "tidyselect", "tidyverse", "tinytex", "utf8", "vctrs", "viridis", "viridisLite", "waldo", "withr", "xfun", "zoo"))
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "days")
library(arfima)
library(astsa)
library(xts)
library(janitor); library(magrittr); library(arfima); library(astsa); library(forecast); library(fGarch)
library(rugarch); library(tseries); library(timeSeries); library(ltsa); library(timeDate); library(zoo)
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
setwd("~/Desktop/OneDrive - Aalborg Universitet/Projekter/P6/bachelorR/Bachelor")
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(from = as.Date("2013-10-01"), to = as.Date("2021-04-19"), by = "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
return <- diff(closing_price) /closing_price[1:2757]
# All MIM and AMIM
ar.all <- ar.mle(return, aic = TRUE, order.max = NULL, intercept = TRUE); ar.all #AR(10)
acf2(ar.all)
acf2(return)
log(8)
library(TSA)
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
return <- diff(closing_price) / closing_price[1:2757]
arma.mod <- auto.arima(return, approximation = FALSE, stepwise = FALSE, allowmean = FALSE,
allowdrift = FALSE); coeftest(arma.mod) # ARMA(4,1)
library(fUnitRoots)
library(ie2misc)
library(itsmr)
library(lmtest)
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(as.Date("2013-10-01"), as.Date("2021-04-19"), "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
return <- diff(closing_price) / closing_price[1:2757]
arma.mod <- auto.arima(return, approximation = FALSE, stepwise = FALSE, allowmean = FALSE,
allowdrift = FALSE); coeftest(arma.mod) # ARMA(4,1)
ar.mod <- ar.mle(return, aic = TRUE, order.max = NULL, intercept = TRUE) # AR(10)
# Calculating the accuracy of the models, first for the auto.arima the for ar.mle
accuracy(fitted(arma.mod), return)
MSE(fitted(arma.mod), return)
library(rmgarch)
library(quantmod)
library(MLmetrics)
library(misc3d)
MSE(fitted(arma.mod), return)
# Calculating the fitted values, and finding the accuracy
fitted.ar.mod <- ts(return[11:2756] - ar.mod$resid[11:2756])
MSE(fitted.ar.mod, return[11:2756])
accuracy(fitted.ar.mod, return[11:2756])
# Checking if the residuals are indeed white noise
checkresiduals(arma.mod)
# Forecasting using ARMA(4,1)
tendaysahead <- read.table("BTC_USD_2021-04-20_2021-04-29-CoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
tenaheaddates <- as.Date(tendaysahead$Date)
td.tenahead <- seq(as.Date("2021-04-20"), as.Date("2021-04-29"), "days")
closing_price.tenahead <- zoo(x = tendaysahead$Closing.Price..USD., order.by = td.tenahead)
tendaysahead.return <- diff(closing_price.tenahead) / closing_price.tenahead[1:9]
t.all <- seq(as.Date("2013-01-01"), as.Date("2021-04-29"), by = "month")
arma.forecast <- forecast::forecast(arma.mod, h = 10, level = c(80, 95))
par(mfrow = c(1,1))
plot(arma.forecast, xaxt = "n", main = "10 Days ahead Forecast, ARMA(4,1)", xlim = c(18300, 18733))
lines(tendaysahead.return, type = "l", col = "green",
lty = 2); axis.Date(1, at = t.all, format= "%m/%Y", las = 2)
legend("bottomleft", legend = c("Actual Returns 20/2 - 19/4/21",
"Forecast", "Actual Returns 20/4/21 - 29/4/21"),
col = c("black", "steelblue", "green"), lty = c(1,1,2), cex = 0.55, box.lty = 0)
residual.analysis <- function(model, std = TRUE, start = 2, class = c("ARIMA","GARCH","ARMA-GARCH")[1]){
library(TSA)
library(FitAR)
if (class == "ARIMA"){
if (std == TRUE){
res.model = rstandard(model)
}else{
res.model = residuals(model)
}
}else if (class == "GARCH"){
res.model = model$residuals[start:model$n.used]
}else if (class == "ARMA-GARCH"){
res.model = model@fit$residuals
}else {
stop("The argument 'class' must be either 'ARIMA' or 'GARCH' ")
}
par(mfrow = c(3,2))
plot(res.model, type = 'o', ylab = 'Standardized Residuals',
main = "Time Series plot of Standardized Residuals")
abline(h = 0)
hist(res.model, main = "Histogram of Standardized Residuals")
acf(res.model, main = "ACF of Standardized Residuals")
pacf(res.model, main = "PACF of Standardized Residuals")
qqnorm(res.model, main = "QQ plot of Standardized Residuals")
qqline(res.model, col = 2)
print(shapiro.test(res.model))
k = 0
LBQPlot(res.model, lag.max = 30, StartLag = k + 1, k = 0, SquaredQ = FALSE)
}
residual.analysis(arma.mod, std = TRUE, start = 1)
par(mfrow = c(1,1))
McLeod.Li.test(arma.mod, main = "McLeod-Li test statistics for Returns")
abs.return <- abs(return); acf2(abs.return) # Shows signs of ARCH effect
sqr.return <- return^2; acf2(sqr.return) # Shows signs of ARCH effect
# ARMA(3,2)-GARCH(4,2) lowest BIC = -3.77051
arma32.garch42 <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(4,2)),
mean.model = list(armaOrder = c(3,2), include.mean = TRUE),
distribution.model = "norm")
arma32.garch42.fit <- ugarchfit(spec = arma32.garch42, data = return,
out.sample = 100, solver = "hybrid")
par(mfrow = c(4,3))
plot(arma32.garch42.fit, which = "all")
arma32.garch42.fit
# Checking goodness of fit for mean and variance prediction, and for the distribution
e <- residuals(arma32.garch42.fit); mean(e^2) # = 0.00187
d <- e^2 - sigma(arma32.garch42.fit)^2; mean(d^2) # = 4.0661e-05
likelihood(arma32.garch42.fit) # = 5,058.484
par(mfrow = c(1,1))
# Observing if the above conclusion is correct
stand.res <- residuals(arma32.garch42.fit, standardize = TRUE)
acf(stand.res, main = "Standardized Residuals")
sqr.stand.res <- stand.res^2
acf(sqr.stand.res, main = "Squared Standardized Residuals")
# Calculating the accuracy of the model
MSE(arma32.garch42.fit@fit$fitted.values, return)
accuracy(arma32.garch42.fit@fit$fitted.values, return[2656:2757])
# Forecasting; static and rolling, conditional mean and sigma
forecast_arma32garch42 <- ugarchforecast(arma32.garch42.fit,
data = return, n.ahead = 10, n.roll = 100)
print(forecast_arma32garch42)
plot(forecast_arma32garch42, which = "all")
######################################################################################
# Based on AMIM value, the models are made based on the inefficient years, i.e., 2014 & 2015
######################################################################################
t2 <- window(return, start = as.Date("2014-01-01"), end = as.Date("2014-12-31")) #Inefficient
t3 <- window(return, start = as.Date("2015-01-01"), end = as.Date("2015-12-31")) #Inefficient
######################################################################################
# ARMA-GARCH model for 2014, static and rolling forecast
# Based on BIC, the best model is ARMA(2,4)-GARCH(1,1), BIC = -3.797563
######################################################################################
return2014 <- return[92:456]
arma.mod2014 <- auto.arima(return2014, approximation = FALSE, stepwise = FALSE, allowmean = FALSE,
allowdrift = FALSE); coeftest(arma.mod2014) # AR(2)
ar.mod2014 <- ar.mle(return2014, aic = TRUE, order.max = NULL, intercept = TRUE) #AR(2)
# Calculating the accuracy of both models, first from auto.arima then from ar.mle
MSE(fitted(arma.mod2014), return2014)
accuracy(fitted(arma.mod2014), return2014)
MSE(fitted(ar.mod2014)[3:365], return2014[3:365])
accuracy(fitted(ar.mod2014)[3:365], return2014[3:365])
######################################################################################
# Based on AMIM value, the models are made based on the inefficient months.
# Three months are chosen, highest: October 16, lowest: May 18, median: September 18
######################################################################################
#Monthly Windows:
oct2016 <- window(return, start = as.Date("2016-10-01"), end = as.Date("2016-10-31")) # Highest
nov2016 <- window(return, start = as.Date("2016-11-01"), end = as.Date("2016-11-30"))
may2018 <- window(return, start = as.Date("2018-05-01"), end = as.Date("2018-05-31")) # Lowest
jun2018 <- window(return, start = as.Date("2018-06-01"), end = as.Date("2018-06-30"))
sep2018 <- window(return, start = as.Date("2018-09-01"), end = as.Date("2018-09-30")) # Median
oct2018 <- window(return, start = as.Date("2018-10-01"), end = as.Date("2018-10-31"))
######################################################################################
# Month with highest AMIM - Oct. 2016 = 0.5026904, modelling
######################################################################################
arma.oct2016 <- auto.arima(oct2016, trace = TRUE, stepwise = FALSE, approximation = FALSE,
allowmean = FALSE, allowdrift = FALSE) # ARMA(0,0,0)
ar.oct2016 <- ar.mle(oct2016, aic = TRUE, order.max = NULL, intercept = TRUE) # AR(11)
# Calculating the accuracy of both models, first from auto.arima then from ar.mle
MSE(fitted(arma.oct2016), oct2016)
accuracy(fitted(arma.oct2016), oct2016)
MSE(fitted(ar.oct2016)[12:31], oct2016[12:31])
accuracy(fitted(ar.oct2016)[12:31], oct2016[12:31])
residual.analysis(arma.oct2016, std = TRUE, start = 1)
par(mfrow = c(1,1))
McLeod.Li.test(arma.oct2016, main = "McLeod-Li test statistics for Returns Oct. 2016")
infocriteria(arimaFit(return, order = c(0,0,0)))
infocriteria(Arima(return, order = c(0,0,0)))
# Checking if the residuals are indeed white noise
checkresiduals(arma.mod)
par(mfrow = c(1,1))
McLeod.Li.test(arma.mod, main = "McLeod-Li test statistics for Returns")
abs.return <- abs(return); acf2(abs.return) # Shows signs of ARCH effect
sqr.return <- return^2; acf2(sqr.return) # Shows signs of ARCH effect
# ARMA(3,2)-GARCH(4,2) lowest BIC = -3.77051
arma32.garch42 <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(4,2)),
mean.model = list(armaOrder = c(3,2), include.mean = TRUE),
distribution.model = "norm")
arma32.garch42.fit <- ugarchfit(spec = arma32.garch42, data = return,
out.sample = 100, solver = "hybrid")
arma32.garch42.fit
# Forecasting; static and rolling, conditional mean and sigma
forecast_arma32garch42 <- ugarchforecast(arma32.garch42.fit,
data = return, n.ahead = 10, n.roll = 100)
print(forecast_arma32garch42)
plot(forecast_arma32garch42)
lines(return, lty = 2, col = "black")
plot(forecast_arma32garch42)
lines(return, type = "o", col = "black")
Bitcoin_df<- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
dates <- as.Date(Bitcoin_df$Date)
td <- seq(from = as.Date("2013-10-01"), to = as.Date("2021-04-19"), by = "days")
closing_price <- zoo(x = Bitcoin_df$Closing.Price..USD., order.by = td)
return <- diff(closing_price) /closing_price[1:2757]
# All MIM and AMIM
ar.all <- ar.mle(return, aic = TRUE, order.max = NULL, intercept = TRUE); ar.all #AR(10)
######################################################################################
# Based on AMIM value, a model is made based on the whole data
######################################################################################
ar10.all <- ar.mle(return, aic = TRUE, order.max = NULL, intercept = TRUE); ar10.all
fitted.ar10.mod <- ts(return[11:2756] - ar10.all$resid[11:2756])
MSE(fitted.ar10.mod, return[11:2756])
accuracy(fitted.ar10.mod, return[11:2756])
ar.forecast <- forecast::forecast(ar10.all, h = 10, level = c(80, 95))
forecast::forecast(ar10.all)
ar10.all
ar.mod2014
