Upper <- chol(covar.matrix)
Lower <- t(Upper)
covar.matrix == Lower%*%t(Lower)
Lower
covar.matrix == tcrossprod(Lower)
covar.matrix == crossprod(Upper)
covar.matrix <- fit$var.coef
beta.hat <- fit$coef
Upper <- chol(covar.matrix)
Lower <- t(Upper)
beta.stand <- solve(Lower)%*%beta.hat
mim <- (sum(abs(beta.stand)))/(1+sum(abs(beta.stand)))
model <- ar(logprice.df, aic = TRUE, demean = TRUE, method = "yw") #AR(32) model
summary(model)
model$ar
beta.standard <- solve(Lower.mat)%*%beta.hat
beta.hat <- model$ar
beta.standard <- solve(Lower.mat)%*%beta.hat
mim1 <- beta.standard[1]/(1+beta.standard[1])
mim1 <- abs(beta.standard[1])/(1+abs(beta.standard[1]))
mim.vec <- c(rep(0, 32))
mim.vec <- c(rep(0, 32))
mim.t <- function(t){
for (t in 1:32) {
mim_t <- abs(beta.standard[t])/(1+abs(beta.standard[t]))
}
}
View(mim.t)
mim.t <- for (i in 1:32) {
mim_t <- abs(beta.standard[i])/(1+abs(beta.standard[i]))
print[mim_t[i]] }
mim.t <- for (i in 1:32) {
mim_t <- abs(beta.standard[i])/(1+abs(beta.standard[i]))
print(mim_t[i]) }
for (i in 1:32) {
mim_t <- abs(beta.standard[i])/(1+abs(beta.standard[i]))
print(mim_t[i])
}
mim_t <- 0
for (i in 1:32) {
mim_t <- abs(beta.standard[i])/(1+abs(beta.standard[i]))
print(mim_t[i])
}
mim_t <- c(rep(0, 32))
for (i in 1:32) {
mim_t <- abs(beta.standard[i])/(1+abs(beta.standard[i]))
print(mim_t[i])
}
mim_t <- c(rep(0, 32))
for (i in 1:32) {
mim_t <- abs(beta.standard[i])/(1+abs(beta.standard[i]))
next
print(mim_t[i])
}
t <- 32
for (i in 1:t) {
mim_t <- abs(beta.standard[i])/(1+abs(beta.standard[i]))
print(mim_t[i])
}
length(mim_t)
mim_t <- c(rep(0, 32))
length(mim_t)
mim_t <- c(rep(0, 32))
t <- 1:32
mim_t <- numeric(length = length(mim_t))
for (i in seq_along(t)) {
mim_t[i] <- abs(beta.standard[i])/(1+abs(beta.standard[i]))
}
mim_t
plot(mim_t)
plot(mim_t, type = "l")
plot(x = beta.standard, y = mim_t, type = "l")
plot(x = abs(beta.standard), y = mim_t, type = "l")
plot(x = abs(beta.standard[1:32]), y = mim_t, type = "l")
plot(x = sum(abs(beta.standard)), y = mim_t, type = "l")
plot(x = abs(beta.standard), y = mim_t, type = "l")
mim <- (sum(abs(beta.standard)))/(1+sum(abs(beta.standard))) #MIM = 0.9778, which is almost 1,
plot(sum(abs(beta.standard)), mim, type = "l")
#Hence, the model should be an ARMA(3,2).
fit$aic
fit$bic
fic$aicc
fit$aicc
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
closing_price <- Bitcoin_data[,3]
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
#Taking the log-prices, due to financial prospects.
logprice <- log(closing_price)
adf.test(logprice, k = 0) #Dickey-Fuller test if stationary
adf.test(logprice)
#Taking the first difference of the log-prices, to make the time series stationary
logprice.df <- diff(logprice)
adf.test(logprice.df, k = 0) #Dickey-Fuller test with p-val < 0.01, hence stationary.
adf.test(logprice)
adf.test(logprice.df)
adf.test(closing_price, k = 0)
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
View(Bitcoin_data)
closing_price <- Bitcoin_data[,3]
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
adf.test(closing_price, k = 0) #Definitely not stationary
#Taking the log-prices, due to financial prospects.
logprice <- log(closing_price)
adf.test(logprice, k = 0) #Dickey-Fuller test if stationary
#p-val = 0.7886, hence NOT stationary, plot to see
plot.ts(logprice, ylab = "Log-Prices (USD)") #The time series is definitely not stationary
acf(logprice) #Slow decrease suggest good idea to difference the log-prices.
#Taking the first difference of the log-prices, to make the time series stationary
logprice.df <- diff(logprice)
plot.ts(logprice.df, ylab = expression(paste(nabla, "log-Price")))
adf.test(logprice.df, k = 0) #Dickey-Fuller test with p-val < 0.01, hence stationary.
acf2(logprice.df) #The ACF and PACF for the first difference of the logged prices
fit <- auto.arima(logprice.df) #R's build-in function, to estimate the order of the ARMA model
#Hence, the model should be an ARMA(3,2).
fit
fit$aic
model <- ar(logprice.df, aic = TRUE, demean = TRUE, method = "yw") #AR(32) model
summary(model)
model$aic
?ar
model <- ar(logprice.df, aic = TRUE, demean = TRUE, method = "yw", order.max = 20) #AR(32) model
model$aic
model <- ar(logprice.df, aic = FALSE, demean = TRUE, method = "yw") #AR(32) model
model
model
ARMAtoAR(ar = 3, ma = 2)
?ARMAtoAR
ARMAtoAR(ar = 3, ma = 2, lag.max = 10)
model <- ar(logprice.df, aic = FALSE, demean = TRUE, method = "yw") #AR(32) model
model
model$aic
model$ar
covar.matrix <- model$asy.var.coef #Asymptotic covariance matrix
beta.hat <- model$ar
eigen(covar.matrix) #The matrix only has positive eigenvalues => positive definite.
Upper.mat <- chol(covar.matrix) #Gives upper triangular matrix
Lower.mat <- t(Upper.mat) #Makes the lower triangular matrix
covar.matrix == tcrossprod(Lower.mat) #Does not print true in all entries.
view(covar.matrix == tcrossprod(Lower.mat)) #Does not print true in all entries.
View(covar.matrix == tcrossprod(Lower.mat)) #Does not print true in all entries.
View(tcrossprod(Lower.mat)) #Does not print true in all entries.
View(covar.matrix)
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
closing_price <- Bitcoin_data[,3]
log.return <- log(diff(closing_price))
log.return <- diff(log(closing_price))
AR <- c(0.8)
MA <- c(0)
ARMAtoAR(ar = AR, ma = MA, lag.max = 20)
ARMAtoAR(ar = AR, ma = MA)
View(Bitcoin_data)
closing_price <- ts(closing_price, start = c(2013, 3), frequency = 4)
View(closing_price)
closing_price <- Bitcoin_data[,3]
closing_price <- Bitcoin_data[,3]
log.return <- diff(log(closing_price))
fit <- auto.arima(logprice.df) #R's build-in function, to estimate the order of the ARMA model
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
closing_price <- Bitcoin_data[,3]
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
adf.test(closing_price, k = 0) #Definitely not stationary
#Taking the log-prices, due to financial prospects.
logprice <- log(closing_price)
adf.test(logprice, k = 0) #Dickey-Fuller test if stationary
#p-val = 0.7886, hence NOT stationary, plot to see
plot.ts(logprice, ylab = "Log-Prices (USD)") #The time series is definitely not stationary
acf(logprice) #Slow decrease suggest good idea to difference the log-prices.
#Taking the first difference of the log-prices, to make the time series stationary
logprice.df <- diff(logprice)
plot.ts(logprice.df, ylab = expression(paste(nabla, "log-Price")))
adf.test(logprice.df, k = 0) #Dickey-Fuller test with p-val < 0.01, hence stationary.
kpss.test(logprice.df) #Here, the null hypothesis is that the time series is stationary
acf2(logprice.df) #The ACF and PACF for the first difference of the logged prices
fit <- auto.arima(logprice.df) #R's build-in function, to estimate the order of the ARMA model
#Hence, the model should be an ARMA(3,2).
fit
#Hence, the model should be an ARMA(3,2).
fit$coef
#Hence, the model should be an ARMA(3,2).
fit$coef[1:3]
ARMAtoAR(ar = fit$coef[1:3], ma = fit$coef[4:5])
ARMAtoAR(ar = 3, ma = 2)
ARMAtoAR(ar = .3, ma = .2)
ARMAtoAR(ar = 3, ma = 2)
ARMAtoAR(ar = fit$coef[1:3], ma = fit$coef[4:5])
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
closing_price <- Bitcoin_data[,3]
log.return <- diff(log(closing_price))
model <- auto.arima(log.return) #R's build-in function, to estimate the order of the ARMA model
#Hence, the model should be an ARMA(3,2).
AR <- model$coef[1:3]
MA <- model$coef[4:5]
ARMAtoAR(ar = AR, ma = MA)
AR.model <- ARMAtoAR(ar = AR, ma = MA)
beta.hat <- ARMAtoAR(ar = AR, ma = MA) #AR(20)
cov(beta.hat)
covariance <- cov(beta.hat, beta.hat)
AR.model <- ARMAtoAR(ar = AR, ma = MA) #AR(20)
beta.hat <- c(AR.model)
covariance <- cov(beta.hat, beta.hat)
beta.hat <- as.vector(AR.model)
covariance <- cov(beta.hat, beta.hat)
covariance <- vcov(beta.hat, beta.hat)
?ar
modell <- ar(log.return, aic = TRUE, method = "yw", order.max = 20)
modell$ar
AR.model <- ARMAtoAR(ar = AR, ma = MA, lag.max = 10) #AR(20)
AR.model
model <- lm(log.return[2743] ~ 0.034log.return[2742] + 0.018log.return[2741] - 0.022log.return[2740]
- 0.032log.return[2739] - 0.032log.return[2738] - 0.029log.return[2737]
- 0.026log.return[2736] - 0.022log.return[2735] - 0.019log.return[2734]
- 0.017log.return[2733] - 0.014log.return[2732] - 0.012log.return[2731]
- 0.011log.return[2730] - 0.009log.return[2729] - 0.008log.return[2728]
- 0.007log.return[2727] - 0.006log.return[2726] - 0.005log.return[2725]
- 0.004log.return[2724] - 0.004log.return[2723], data = log.return)
model <- lm(log.return[2743] ~ 0.034*log.return[2742] + 0.018*log.return[2741] - 0.022*log.return[2740]
- 0.032*log.return[2739] - 0.032*log.return[2738] - 0.029*log.return[2737]
- 0.026*log.return[2736] - 0.022*log.return[2735] - 0.019*log.return[2734]
- 0.017*log.return[2733] - 0.014*log.return[2732] - 0.012*log.return[2731]
- 0.011*log.return[2730] - 0.009*log.return[2729] - 0.008*log.return[2728]
- 0.007*log.return[2727] - 0.006*log.return[2726] - 0.005*log.return[2725]
- 0.004*log.return[2724] - 0.004*log.return[2723], data = log.return)
log.return[2725]
0.005*log.return[2725]
beta.hat <- as.matrix(AR.model)
covariance <- cov(beta.hat, beta.hat)
View(covariance)
?arima.sim
#Hence, the model should be an ARMA(3,2).
AR <- c(model$coef[1:3])
MA <- c(model$coef[4:5])
AR.model <- ARMAtoAR(ar = AR, ma = MA) #AR(20)
arima.sim(list(ar = AR, ma = MA))
AR.model <- ARMAtoAR(ar = AR, ma = MA) #AR(20)
arima.sim(n = 20, list(ar = beta.hat))
plot(arima.sim(n = 20, list(ar = beta.hat)))
arima(log.return, order = c(20,0,0))
AR.model <- ARMAtoAR(ar = AR, ma = MA) #AR(20)
ARMAtoAR(ar = AR, ma = MA) #AR(20)
arima <- arima(log.return, order = c(20,0,0))
arima <- arima(log.return, order = c(20,0,0))
arima1 <- arima(log.return, order = c(20,0,0))
arima1$coef
arima1$var.coef
comat <- arima1$var.coef
chol(comat)
U <- chol(comat)
L <- t(U)
comat = tcrossprod(LL)
comat = tcrossprod(L)
comat == tcrossprod(L)
L.inv <- solve(L)
beta.stand <- L.inv %*% arima1$coef
mean(beta.stand)
MIM <- (sum(abs(beta.stand)))/1+sum(abs(beta.stand))
MIM <- (sum(abs(beta.stand)))/(1+sum(abs(beta.stand)))
class(closing_price)
closing_price <- as.ts(Bitcoin_data[,3])
class(closing_price)
closing_price <- as.ts(Bitcoin_data[,3])
log.return <- diff(log(closing_price))
model <- auto.arima(log.return) #R's build-in function, to estimate the order of the ARMA model
#Hence, the model should be an ARMA(3,2).
AR <- c(model$coef[1:3]) #AR coefficients from the ARMA(3,2) model.
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
closing_price <- as.ts(Bitcoin_data[,3])
log.return <- diff(log(closing_price))
model <- auto.arima(log.return) #R's build-in function, to estimate the order of the ARMA model
#Hence, the model should be an ARMA(3,2).
AR <- c(model$coef[1:3]) #AR coefficients from the ARMA(3,2) model.
model
MA <- c(model$coef[4:5]) #MA coefficients from the ARMA(3,2) model.
ARMAtoAR(ar = AR, ma = MA) #AR(20)
arima1 <- arima(log.return, order = c(20,0,0)) #Simulating the AR(20) model.
arima1$coef
start(closing_price)
end(closing_price)
summary(closing_price)
plot(closing_price)
?ar
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
closing_price <- as.ts(Bitcoin_data[,3])
View(log.return)
Bitcoin_data <- read.table("market-price.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
View(Bitcoin_data)
Bitcoin_data1 <- read.table("market-price.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
View(Bitcoin_data)
View(Bitcoin_data1)
library(c(corrgram, astsa, TSA, tseries, forecast))
library(fGarch)
head(Bitcoin_data)
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
head(Bitcoin_data)
ggplot2::ggplot(data = Bitcoin_data[2:3], xlab = "Date", ylab = "Closing.Price..USD.")
str(Bitcoin_data)
ggplot2::ggplot(data = Bitcoin_data, xlab = "Date", ylab = "Closing.Price..USD.")
ggplot2::ggplot(data = Bitcoin_data, aes(x = DATE, y =CLOSINGPRICE) xlab = "Date", ylab = "Closing.Price..USD.")
ggplot2::ggplot(data = Bitcoin_data, aes(x = DATE, y =CLOSINGPRICE), xlab = "Date", ylab = "Closing.Price..USD.")
ggplot2::ggplot(x = Bitcoin_data[3], y = Bitcoin_data[2], xlab = "Date", ylab = "Closing.Price..USD.")
ggplot2::ggplot(x = Bitcoin_data[3], y = Bitcoin_data[2], xlab = "Date",
ylab = "Closing.Price..USD.", xlim = c(0,3000))
ggplot2::ggplot(x = Bitcoin_data[3], y = Bitcoin_data[2], xlab = "Date",
ylab = "Closing.Price..USD.", xlim = c(0,3000), ylim = c(0,400))
Bitcoin_data$Date <- as.Date(Bitcoin_data$Date, format = "%Y-%m-%d")
class(Bitcoin_data$Date)
head(Bitcoin_data$Date)
ggplot2::ggplot(data = Bitcoin_data, aes(x = DATE, y = CLOSINGPRICE) +
geom_bar(stat = "identity", fill = "purple") +
labs(title = "Total daily precipitation in Boulder, Colorado",
subtitle = "Fall 2013",
x = "Date", y = "Daily Precipitation (Inches)")))
ggplot2::ggplot(data = Bitcoin_data, aes(x = DATE, y = CLOSINGPRICE) +
geom_bar(stat = "identity", fill = "purple") +
labs(title = "Total daily precipitation in Boulder, Colorado",
subtitle = "Fall 2013",
x = "Date", y = "Daily Precipitation (Inches)"))
?aes
library(ggplot2)
ggplot(data = Bitcoin_data, aes(x = DATE, y = CLOSINGPRICE) +
geom_bar(stat = "identity", fill = "purple") +
labs(title = "Total daily precipitation in Boulder, Colorado",
subtitle = "Fall 2013",
x = "Date", y = "Daily Precipitation (Inches)"))
ggplot(data = Bitcoin_data, aes(x = DATE, y = CLOSINGPRICE)) +
geom_bar(stat = "identity", fill = "purple") +
labs(title = "Total daily precipitation in Boulder, Colorado",
subtitle = "Fall 2013",
x = "Date", y = "Daily Precipitation (Inches)"))
ggplot(data = Bitcoin_data, aes(x = DATE, y = CLOSINGPRICE)) +
geom_bar(stat = "identity", fill = "purple") +
labs(title = "Total daily precipitation in Boulder, Colorado",
subtitle = "Fall 2013",
x = "Date", y = "Daily Precipitation (Inches)")
ggplot(data = Bitcoin_data, aes(x = Date, y = Closing.Price..USD)) +
geom_bar(stat = "identity", fill = "purple") +
labs(title = "Total daily precipitation in Boulder, Colorado",
subtitle = "Fall 2013",
x = "Date", y = "Daily Precipitation (Inches)")
ggplot(data = Bitcoin_data, aes(x = Date, y = Closing.Price..USD.)) +
geom_bar(stat = "identity", fill = "purple") +
labs(title = "Total daily precipitation in Boulder, Colorado",
subtitle = "Fall 2013",
x = "Date", y = "Daily Precipitation (Inches)")
plot.ts(y = closing_price, x = Bitcoin_data$Date, ylab = "Closing Price (USD)") #Looks non-stationary
closing_price <- Bitcoin_data[,3]
plot.ts(y = closing_price, x = Bitcoin_data$Date, ylab = "Closing Price (USD)") #Looks non-stationary
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
adf.test(closing_price, k = 0) #Definitely not stationary
#Taking the log-prices, due to financial prospects.
logprice <- log(closing_price)
adf.test(logprice, k = 0) #Dickey-Fuller test if stationary
#p-val = 0.7886, hence NOT stationary, plot to see
plot.ts(logprice, ylab = "Log-Prices (USD)") #The time series is definitely not stationary
acf(logprice) #Slow decrease suggest good idea to difference the log-prices.
#Taking the first difference of the log-prices, to make the time series stationary
logreturn <- diff(logprice)
plot.ts(logreturn, ylab = "log-return")
adf.test(logreturn, k = 0) #Dickey-Fuller test with p-val < 0.01, hence stationary.
adf.test(logreturn)
pp.test(logreturn)
fit <- auto.arima(logreturn) #R's build-in function, to estimate the order of the ARMA model
check(fit)
?check
install.packages("itsmr")
library(itsmr)
check(fit)
#Hence, the model should be an ARMA(3,2).
summary(fit)
arma.model <- specify(ar = c(1.1751, -0.2757, 0.0335), ma = c(-1.2092, 0.2991))
check(arma.model)
?itsmr::check
?is.timeSeries
is.timeSeries(closing_price)
is.timeSeries(logprice)
is.timeSeries(logreturn)
?as.timeSeries
Bitcoin_data <- as.timeSeries(Bitcoin_data)
is.timeSeries(closing_price)
is.timeSeries(Bitcoin_data)
closing_price <- as.timeSeries(Bitcoin_data[,3])
View(closing_price)
is.timeSeries(closing_price)
is.timeSeries(logprice)
#Taking the log-prices, due to financial prospects.
logprice <- as.timeSeries(log(closing_price))
adf.test(logprice, k = 0) #Dickey-Fuller test if stationary, p-val = 0.7886, hence NOT stationary
adf.test(logprice) #Augmented Dickey-Fuller, NOT stationary
pp.test(logprice) #Phillips & Perron test, NOT stationary
plot.ts(logprice, ylab = "Log-Prices (USD)") #The time series is definitely not stationary
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
closing_price <- as.timeSeries(Bitcoin_data[,3])
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
Bitcoin_data <- as.timeSeries(Bitcoin_data)
closing_price <- Bitcoin_data[,3]
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
Bitcoin_data <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
closing_price <- Bitcoin_data[,3]
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
adf.test(closing_price, k = 0) #Definitely not stationary
adf.test(closing_price) #Augmented DF, NOT stationary
pp.test(closing_price) #Phillips & Perron test, NOT stationary
#Taking the log-prices, due to financial prospects.
logprice <- log(closing_price)
adf.test(logprice, k = 0) #Dickey-Fuller test if stationary, p-val = 0.7886, hence NOT stationary
adf.test(logprice) #Augmented Dickey-Fuller, NOT stationary
pp.test(logprice) #Phillips & Perron test, NOT stationary
plot.ts(logprice, ylab = "Log-Prices (USD)") #The time series is definitely not stationary
acf(logprice) #Slow decrease suggest good idea to difference the log-prices.
#Taking the first difference of the log-prices, to make the time series stationary
logreturn <- diff(logprice)
plot.ts(logreturn, ylab = "log-return")
adf.test(logreturn, k = 0) #Dickey-Fuller test with p-val < 0.01, hence stationary.
adf.test(logreturn) #Augmented DF, stationary
pp.test(logreturn) #Phillips & Perron test, stationary
acf2(logreturn) #The ACF and PACF for the first difference of the logged prices
fit <- auto.arima(logreturn) #R's build-in function, to estimate the order of the ARMA model
#Hence, the model should be an ARMA(3,2).
summary(fit)
arma.model <- specify(ar = c(1.1751, -0.2757, 0.0335), ma = c(-1.2092, 0.2991))
check(arma.model)
closing_price <- as.ts(Bitcoin_data[,3])
log.return <- diff(log(closing_price))
model <- auto.arima(log.return) #R's build-in function, to estimate the order of the ARMA model
#Hence, the model should be an ARMA(3,2).
AR <- c(model$coef[1:3]) #AR coefficients from the ARMA(3,2) model.
MA <- c(model$coef[4:5]) #MA coefficients from the ARMA(3,2) model.
ARMAtoAR(ar = AR, ma = MA) #AR(20)
arima1 <- arima(log.return, order = c(20,0,0)) #Simulating the AR(20) model.
arima1$coef
acf(logreturn)
pacf(logreturn)
acf2(fit)
ARMA <- arima(logreturn, order = c(3,0,2))
summary(ARMA)
class(Bitcoin_data)
Bitcoin_data <- as.matrix(read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE))
class(Bitcoin_data)
Bitcoin_data <- as.matrix(read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE))
closing_price <- Bitcoin_data[,3]
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
adf.test(closing_price, k = 0) #Definitely not stationary
adf.test(closing_price) #Augmented DF, NOT stationary
pp.test(closing_price) #Phillips & Perron test, NOT stationary
#Taking the log-prices, due to financial prospects.
logprice <- log(closing_price)
class(closing_price)
closing_price <- as.numeric(Bitcoin_data[,3])
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
adf.test(closing_price, k = 0) #Definitely not stationary
adf.test(closing_price) #Augmented DF, NOT stationary
pp.test(closing_price) #Phillips & Perron test, NOT stationary
#Taking the log-prices, due to financial prospects.
logprice <- log(closing_price)
adf.test(logprice, k = 0) #Dickey-Fuller test if stationary, p-val = 0.7886, hence NOT stationary
adf.test(logprice) #Augmented Dickey-Fuller, NOT stationary
pp.test(logprice) #Phillips & Perron test, NOT stationary
plot.ts(logprice, ylab = "Log-Prices (USD)") #The time series is definitely not stationary
acf(logprice) #Slow decrease suggest good idea to difference the log-prices.
#Taking the first difference of the log-prices, to make the time series stationary
logreturn <- diff(logprice)
plot.ts(logreturn, ylab = "log-return")
adf.test(logreturn, k = 0) #Dickey-Fuller test with p-val < 0.01, hence stationary.
adf.test(logreturn) #Augmented DF, stationary
pp.test(logreturn) #Phillips & Perron test, stationary
acf2(logreturn) #The ACF and PACF for the first difference of the logged prices
acf(logreturn)
pacf(logreturn)
fit <- auto.arima(logreturn) #R's build-in function, to estimate the order of the ARMA model
#Hence, the model should be an ARMA(3,2).
summary(fit)
ARMA <- arima(logreturn, order = c(3,0,2))
summary(ARMA)
arma.model <- specify(ar = c(1.1751, -0.2757, 0.0335), ma = c(-1.2092, 0.2991))
check(arma.model) #The given model is both causal and invetible
View(Bitcoin_data)
library(zoo)
library(zoo)
BTC.df <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
View(Bitcoin_data)
Bitcoin_data <- read.zoo(BTC.df, format = "%Y-%m-%d")
View(BTC.df)
class(BTC.df$Date)
Bitcoin_data <- zoo(BTC.df, seq(from = as.Date("2013-10-01"), to = as.Date("2021-04-19"), by = 1))
class(Bitcoin_data)
View(Bitcoin_data)
BTC.df <- read.table("BitcoinDataCoinDesk.csv", header = TRUE, sep = ",",
stringsAsFactors = FALSE)
Bitcoin_data <- zoo(BTC.df, seq(from = as.Date("2013-10-01"), to = as.Date("2021-04-19"), by = 1))
class(Bitcoin_data)
closing_price <- Bitcoin_data[,3]
class(closing_price)
plot.ts(closing_price, ylab = "Closing Price (USD)") #Looks non-stationary
plot.ts(closing_price, ylab = "Closing Price (USD)", xlim(c(Bitcoin_data[,2]))) #Looks non-stationary
library(itsmr), library(zoo)
library(itsmr); library(zoo)
